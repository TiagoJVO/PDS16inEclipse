/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package org.pds16.pds16asm.generator

import java.io.InputStream
import java.util.ArrayList
import java.util.List
import org.eclipse.core.resources.IMarker
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.Path
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.pds16.pds16asm.pds16asm.impl.EndImpl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class Pds16asmGenerator extends AbstractGenerator {
	val String SYSTEM_ENV_DASM = "DASM_PATH"

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		//Checking for ".end" on file, because if itsn't present there is no need to assemble code
		if(!existsEnd(resource)){
			val errors = new ArrayList<LinedError>()
			//add new error to mark
			errors.add(new LinedError("Missing '.end' at the end of file",1))
			generateErrors(errors,resource)
			return
		}
			
		//assembling
		val InputStream output = executeDasm(resource)
		
		//parsing errors from assembling output
		val List<LinedError> errors = DasmErrorParser.getErrorsFromStream(output)
		
		//marking any errors
	    generateErrors(errors, resource)
	}
	
	/**
	 * @param resource the Resource to search on
	 * 
	 * @return true if End exists in the given Resource
	 */
	def boolean existsEnd(Resource resource) {
		resource.allContents.exists[elem|
			elem.class.equals(EndImpl)
		]
	}
	/**
	 * Marks each LinedError present on the 'errors' list in the given Resource
	 * 
	 * @param errors the List of LinedError
	 * @param resource the Resource where the error will be marked
	 */
	def void generateErrors(List<LinedError> errors, Resource resource) {
		if(!errors.isEmpty){
			//getting relative uri of resource
	    	var rel = resource.URI.toString().substring("platform:/resource".length)
	    	
	    	//get an instance of IResource, where errors can be marked
	    	val sharedFile = ResourcesPlugin.workspace.root.findMember(rel)
	    	errors.forEach[error |
	    		{
		    		val marker = sharedFile.createMarker(IMarker.PROBLEM) 
		      		marker.setAttribute(IMarker.SEVERITY, IMarker.SEVERITY_ERROR)
		      		marker.setAttribute(IMarker.LINE_NUMBER, error.line)
		      		marker.setAttribute(IMarker.MESSAGE, error.description)
	      		}
	      	]
	    }
	}

	/**
	 * Invoke DASM assembler on the given Resource
	 * 
	 * @param resouce the Resource instance
	 * @return an InputStream containing the output of DASM execution
	 */	
	def InputStream executeDasm(Resource resource){
		val List<String> command = new ArrayList<String>()
		
		//system environment variable defined by user with DASM's path
		val String dasmPath = System.getenv(SYSTEM_ENV_DASM)
		
		//adding dasm.exe path to the command
		command.add(dasmPath);
		
		var resourceFullPath = ""
        val resourceRelativePath = resource.URI
		
		//Getting full path of Resource file
		if (resourceRelativePath.isPlatform) 
			resourceFullPath = ResourcesPlugin.workspace.root.getFile(new Path(resourceRelativePath.toPlatformString(true))).rawLocation.toOSString	
		else 
			resourceFullPath = resource.resourceSet.URIConverter.normalize(resourceRelativePath).toFileString
		
		//adding file location to command
		command.add(resourceFullPath)
		
		val ProcessBuilder builder = new ProcessBuilder(command)
		val Process process = builder.start();
		
		//waiting for termination
		process.waitFor()
		
		return process.getInputStream()
	}
}
	
	
